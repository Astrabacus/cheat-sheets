## Optimistic and Pessimistic Lock 乐观锁与悲观锁
- 悲观锁
	- 当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。
	- 这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。
	>  在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。
	>  它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。
	>  悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。
	- 悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）
	- 在数据库中，悲观锁的流程如下：
	> 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。
	> 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。
	> 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
	> 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。
	- 优点与不足
		- 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。
		- 但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；
		- 另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；
		- 还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数
- 乐观锁
	- 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。
	> 它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。
	> 在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。
	> 如果其他事务有更新的话，正在提交的事务会进行回滚。

	- 乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。
	- 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。
	> 数据版本,为数据增加的一个版本标识。
	> 当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。
	> 当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。
	- 实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。
	> 使用版本号实现乐观锁
	> 使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。
	- 优点与不足
		- 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。

- 如何选择
	- 在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。
		- 乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。
		- 悲观锁依赖数据库锁，效率低。更新失败的概率比较低。
	- 随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。